/**
 * `useMapper` just applies a simple mapping function.
 * @param {function} mapFn
 */
export function useMapper(mapFn) {
  return function _useMapper(item) {
    return mapFn(item);
  };
}

/**
 * `useEscape` will stop the fn() process and immediately return if the checkFn
 * returns truthy.
 * @param {function} checkFn
 */
export function useEscape(checkFn) {
  return function _useEscape(item) {
    if (checkFn(item)) {
      this.stopAndReturn(item);
    }

    return false;
  };
}

/**
 * This is an example of an atom initialiser that will initialise the atom
 * during the runtime of the fn().
 * @param {function} uninitialisedAtomFn
 * @param {number} offset
 */
export function makeWithArg(uninitialisedAtomFn, offset) {
  return function _makeWithArg(item) {
    const arg = this.getArg(offset);
    const atomFnLive = uninitialisedAtomFn.call(this, arg);

    return atomFnLive.call(this, item);
  };
}

/**
 * This is an example of an atom decorator that will modify the behaviour of
 * an already initialised atom. `withOutput` specifically takes an output
 * that has been generated by the fn() and pipes that as an input to the
 * passed in atomFn.
 * @param {function} atomFn
 * @param {number} offset
 */
export function withOutput(atomFn, offset) {
  return function _withOutput() {
    return atomFn.call(this, this.getOutput(offset));
  };
}

/**
 * Combine more than one atom together.
 * @param {...function} atoms
 */
export function cohesive(...atoms) {
  return function _cohesive(item) {
    return atoms.reduce((result, atomFn) => {
      const output = atomFn.call(this, result);
      this.setOutput(output);

      return output;
    }, item);
  };
}
